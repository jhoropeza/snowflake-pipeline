name: ❄️ Despliegue de Notebooks y Fetch

on:
  push:
    branches:
      - '*' 

  workflow_dispatch:
    inputs:
      deployment_target:
        description: 'Selecciona el esquema de destino (DEV o MAIN)'
        required: true
        type: choice
        options: 
          - DEV
          - MAIN
          
      source_branch:
        description: 'Rama Git de donde se extraerá el código (opcional: deja vacío para usar la rama seleccionada arriba)'
        required: false
        type: string
        default: ''

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python 3.10
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install Python packages
        run: pip install -r requirements.txt
        
      - name: Deploy notebooks and fetch
        env:
          # Variable del entorno de destino (DEV o MAIN)
          ENV_TARGET: ${{ github.event_name == 'push' && (github.ref_name == 'main' && 'MAIN' || 'DEV') || github.event.inputs.deployment_target }}
          
          # Nombre de la rama de Git que dispara el evento (si es push) o la entrada manual.
          SOURCE_BRANCH_NAME_INPUT: ${{ github.event.inputs.source_branch || '' }}
          
          SNOWFLAKE_ACCOUNT: ${{ secrets.SNOWFLAKE_ACCOUNT }}
          SNOWFLAKE_USER: ${{ secrets.SNOWFLAKE_USER }}
          SNOWFLAKE_PASSWORD: ${{ secrets.SNOWFLAKE_PASSWORD }}
          SNOWFLAKE_ROLE: ${{ secrets.SNOWFLAKE_ROLE }}
          SNOWFLAKE_WAREHOUSE: ${{ secrets.SNOWFLAKE_WAREHOUSE }}
          SNOWFLAKE_DATABASE: ${{ secrets.SNOWFLAKE_DATABASE }}
          SNOWFLAKE_SCHEMA: ${{ secrets.SNOWFLAKE_SCHEMA }}
          
        run: |
          # 1. Determinar el Entorno Final (siempre en mayúsculas)
          TARGET_ENV=$(echo $ENV_TARGET | tr '[:lower:]' '[:upper:]')
          
          # 2. Lógica para determinar el nombre de la RAMA DE ORIGEN
          # a) Prioridad 1: Si es un push, usamos el nombre de la rama que ha disparado.
          # b) Prioridad 2: Si es manual y se ha introducido una rama.
          # c) Prioridad 3: Usamos el nombre del entorno en minúsculas (e.g., 'dev' si TARGET_ENV='DEV').
          
          if [ "${{ github.event_name }}" == "push" ]; then
              BRANCH_NAME="${{ github.ref_name }}"
          elif [ "$SOURCE_BRANCH_NAME_INPUT" != "" ]; then
              BRANCH_NAME=$SOURCE_BRANCH_NAME_INPUT
          else
              # Opción por defecto para manual (DEV -> dev, MAIN -> main)
              BRANCH_NAME=$(echo $TARGET_ENV | tr '[:upper:]' '[:lower:]')
          fi
          
          echo "Despliegue a: $TARGET_ENV, Código fuente: $BRANCH_NAME"

          # 3. CREAR ESQUEMA DINÁMICO
          TARGET_SCHEMA_NAME=${TARGET_ENV}_SCHEMA
          echo "Creando o asegurando la existencia del esquema: $TARGET_SCHEMA_NAME en la BD: $SNOWFLAKE_DATABASE"
          snow sql -q "CREATE SCHEMA IF NOT EXISTS $TARGET_SCHEMA_NAME;" \
            --temporary-connection --account $SNOWFLAKE_ACCOUNT --user $SNOWFLAKE_USER \
            --role $SNOWFLAKE_ROLE --warehouse $SNOWFLAKE_WAREHOUSE --database $SNOWFLAKE_DATABASE

          # 4. Primer comando: Fetch de la rama
          snow sql -q "ALTER GIT REPOSITORY DEMO_GIT_REPO_V2 FETCH" \
            --temporary-connection --account $SNOWFLAKE_ACCOUNT --user $SNOWFLAKE_USER \
            --role $SNOWFLAKE_ROLE --warehouse $SNOWFLAKE_WAREHOUSE --database $SNOWFLAKE_DATABASE --schema $SNOWFLAKE_SCHEMA

          # 5. Segundo comando: Ejecutar el script SQL usando las variables dinámicas
          snow sql -q "EXECUTE IMMEDIATE FROM @DEMO_GIT_REPO_V2/branches/$BRANCH_NAME/script_to_deploy_notebooks/deploy_notebooks.sql USING (env => '$TARGET_ENV', branch => '$BRANCH_NAME')" \
            --temporary-connection --account $SNOWFLAKE_ACCOUNT --user $SNOWFLAKE_USER \
            --role $SNOWFLAKE_ROLE --warehouse $SNOWFLAKE_WAREHOUSE --database $SNOWFLAKE_DATABASE --schema $SNOWFLAKE_SCHEMA
